%% Generated by the Erlang ASN.1 BER-compiler version:1.4.5
%% Purpose: encoder and decoder to the types in mod SPNEGOASNOneSpec

-module('SPNEGOASNOneSpec').
-include("SPNEGOASNOneSpec.hrl").
-define('RT_BER',asn1rt_ber_bin).
-asn1_info([{vsn,'1.4.5'},
            {module,'SPNEGOASNOneSpec'},
            {options,[ber,report_errors,{cwd,[47,118,97,114,47,108,111,99,97,108,47,115,114,99,47,115,118,110,47,101,103,115,115,97,112,105,47,101,103,115,115,97,112,105,47,115,114,99]},{outdir,[47,118,97,114,47,108,111,99,97,108,47,115,114,99,47,115,118,110,47,101,103,115,115,97,112,105,47,101,103,115,115,97,112,105,47,115,114,99]},der,{i,[46]},{i,[47,118,97,114,47,108,111,99,97,108,47,115,114,99,47,115,118,110,47,101,103,115,115,97,112,105,47,101,103,115,115,97,112,105,47,115,114,99]}]}]).

-export([encoding_rule/0]).
-export([
'enc_NegotiationToken'/2,
'enc_MechType'/2,
'enc_MechTypeList'/2,
'enc_ContextFlags'/2,
'enc_NegTokenInit'/2,
'enc_NegTokenResp'/2
]).

-export([
'dec_NegotiationToken'/2,
'dec_MechType'/2,
'dec_MechTypeList'/2,
'dec_ContextFlags'/2,
'dec_NegTokenInit'/2,
'dec_NegTokenResp'/2
]).

-export([
'dec_NegotiationToken'/3,
'dec_MechType'/3,
'dec_MechTypeList'/3,
'dec_ContextFlags'/3,
'dec_NegTokenInit'/3,
'dec_NegTokenResp'/3
]).

-export([info/0]).


-export([encode/2,decode/2,encode_disp/2,decode_disp/2]).

encoding_rule() ->
   ber.

encode(Type,Data) ->
case catch encode_disp(Type,Data) of
  {'EXIT',{error,Reason}} ->
    {error,Reason};
  {'EXIT',Reason} ->
    {error,{asn1,Reason}};
  {Bytes,_Len} ->
    {ok,wrap_encode(Bytes)};
  Bytes ->
    {ok,wrap_encode(Bytes)}
end.

decode(Type,Data) ->
case catch decode_disp(Type,wrap_decode(Data)) of
  {'EXIT',{error,Reason}} ->
    {error,Reason};
  {'EXIT',Reason} ->
    {error,{asn1,Reason}};
  {X,_Rest} ->
    {ok,X};
  {X,_Rest,_Len} ->
    {ok,X}
end.

encode_disp('NegotiationToken',Data) -> 'enc_NegotiationToken'(Data,[]);
encode_disp('MechType',Data) -> 'enc_MechType'(Data,[]);
encode_disp('MechTypeList',Data) -> 'enc_MechTypeList'(Data,[]);
encode_disp('ContextFlags',Data) -> 'enc_ContextFlags'(Data,[]);
encode_disp('NegTokenInit',Data) -> 'enc_NegTokenInit'(Data,[]);
encode_disp('NegTokenResp',Data) -> 'enc_NegTokenResp'(Data,[]);
encode_disp(Type,_Data) -> exit({error,{asn1,{undefined_type,Type}}}).


decode_disp('NegotiationToken',Data) -> 'dec_NegotiationToken'(Data,mandatory);
decode_disp('MechType',Data) -> 'dec_MechType'(Data,mandatory);
decode_disp('MechTypeList',Data) -> 'dec_MechTypeList'(Data,mandatory);
decode_disp('ContextFlags',Data) -> 'dec_ContextFlags'(Data,mandatory);
decode_disp('NegTokenInit',Data) -> 'dec_NegTokenInit'(Data,mandatory);
decode_disp('NegTokenResp',Data) -> 'dec_NegTokenResp'(Data,mandatory);
decode_disp(Type,_Data) -> exit({error,{asn1,{undefined_type,Type}}}).



wrap_encode(Bytes) when list(Bytes) ->
   binary_to_list(list_to_binary(Bytes));
wrap_encode(Bytes) when binary(Bytes) ->
   binary_to_list(Bytes);
wrap_encode(Bytes) -> Bytes.

wrap_decode(Bytes) when list(Bytes) ->
   list_to_binary(Bytes);
wrap_decode(Bytes) -> Bytes.


info() ->
   case ?MODULE:module_info() of
      MI when is_list(MI) ->
         case lists:keysearch(attributes,1,MI) of
            {value,{_,Attributes}} when is_list(Attributes) ->
               case lists:keysearch(asn1_info,1,Attributes) of
                  {value,{_,Info}} when is_list(Info) ->
                     Info;
                  _ ->
                     []
               end;
            _ ->
               []
         end
   end.


%%================================
%%  NegotiationToken
%%================================

'enc_NegotiationToken'({'NegotiationToken',Val}, TagIn) ->
   'enc_NegotiationToken'(Val, TagIn);

'enc_NegotiationToken'(Val, TagIn) ->
   {EncBytes,EncLen} = case element(1,Val) of
      negTokenInit ->
         'enc_NegTokenInit'(element(2,Val), [{tag,128,0,'EXPLICIT',32}]);
      negTokenResp ->
         'enc_NegTokenResp'(element(2,Val), [{tag,128,1,'EXPLICIT',32}]);
      Else -> 
         exit({error,{asn1,{invalid_choice_type,Else}}})
   end,

?RT_BER:encode_tags(TagIn ++[], EncBytes, EncLen).




'dec_NegotiationToken'(Bytes, OptOrMand) ->
   'dec_NegotiationToken'(Bytes, OptOrMand, []).

'dec_NegotiationToken'(Bytes, OptOrMand, TagIn) ->
   {{_,Len},Bytes1, RbExp} = ?RT_BER:check_tags(TagIn++[], Bytes, OptOrMand),
   IndefEndBytes = fun(indefinite,<<0,0,R/binary>>)-> R; (_,B)-> B end,
   IndefEndRb = fun(indefinite,<<0,0,_R/binary>>)-> 2; (_,_)-> 0 end,
   case Bytes1 of

%% 'negTokenInit'
      <<2:2,_:1,0:5,_/binary>> ->
         {Dec, Rest, RbCho} = 'dec_NegTokenInit'(Bytes1, mandatory, [{tag,128,0,'EXPLICIT',32}]),
         {{negTokenInit, Dec}, IndefEndBytes(Len,Rest), RbExp + RbCho + IndefEndRb(Len,Rest)};


%% 'negTokenResp'
      <<2:2,_:1,1:5,_/binary>> ->
         {Dec, Rest, RbCho} = 'dec_NegTokenResp'(Bytes1, mandatory, [{tag,128,1,'EXPLICIT',32}]),
         {{negTokenResp, Dec}, IndefEndBytes(Len,Rest), RbExp + RbCho + IndefEndRb(Len,Rest)};

      Else -> 
         case OptOrMand of
            mandatory ->exit({error,{asn1,{invalid_choice_tag,Else}}});
            _ ->exit({error,{asn1,{no_optional_tag,Else}}})
         end
   end.


%%================================
%%  MechType
%%================================

'enc_MechType'({'MechType',Val}, TagIn) ->
   'enc_MechType'(Val, TagIn);

'enc_MechType'(Val, TagIn) ->
?RT_BER:encode_object_identifier(Val, TagIn ++ []).


'dec_MechType'(Bytes, OptOrMand) ->
   'dec_MechType'(Bytes, OptOrMand, []).

'dec_MechType'(Bytes, OptOrMand, TagIn) ->
?RT_BER:decode_object_identifier(Bytes,TagIn++[], OptOrMand).



%%================================
%%  MechTypeList
%%================================

'enc_MechTypeList'({'MechTypeList',Val}, TagIn) ->
   'enc_MechTypeList'(Val, TagIn);

'enc_MechTypeList'(Val, TagIn) ->
   {EncBytes,EncLen} = 'enc_MechTypeList_components'(Val,[],0),
   ?RT_BER:encode_tags(TagIn ++ [{tag,0,16,'IMPLICIT',32}], EncBytes, EncLen).

'enc_MechTypeList_components'([], AccBytes, AccLen) -> 
   {lists:reverse(AccBytes),AccLen};

'enc_MechTypeList_components'([H|T],AccBytes, AccLen) ->
   {EncBytes,EncLen} = ?RT_BER:encode_object_identifier(H, []),
   'enc_MechTypeList_components'(T,[EncBytes|AccBytes], AccLen + EncLen).



'dec_MechTypeList'(Bytes, OptOrMand) ->
   'dec_MechTypeList'(Bytes, OptOrMand, []).

'dec_MechTypeList'(Bytes, OptOrMand, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
   {{_,Len},Bytes1,Rb1} = ?RT_BER:check_tags(TagIn ++ [{tag,0,16,'IMPLICIT',32}], Bytes, OptOrMand), 
   ?RT_BER:decode_components(Rb1, Len, Bytes1, fun(FBytes,_,_)->
?RT_BER:decode_object_identifier(FBytes,[], mandatory)
end, [], []).




%%================================
%%  ContextFlags
%%================================

'enc_ContextFlags'({'ContextFlags',Val}, TagIn) ->
   'enc_ContextFlags'(Val, TagIn);

'enc_ContextFlags'(Val, TagIn) ->
?RT_BER:encode_bit_string([], Val, [{delegFlag,0},{mutualFlag,1},{replayFlag,2},{sequenceFlag,3},{anonFlag,4},{confFlag,5},{integFlag,6}], TagIn ++ []).


'dec_ContextFlags'(Bytes, OptOrMand) ->
   'dec_ContextFlags'(Bytes, OptOrMand, []).

'dec_ContextFlags'(Bytes, OptOrMand, TagIn) ->
?RT_BER:decode_bit_string(Bytes,[],[{delegFlag,0},{mutualFlag,1},{replayFlag,2},{sequenceFlag,3},{anonFlag,4},{confFlag,5},{integFlag,6}],TagIn++[], no_length, OptOrMand).



%%================================
%%  NegTokenInit
%%================================
'enc_NegTokenInit'(Val, TagIn) ->

%%-------------------------------------------------
%% attribute number 1   External SPNEGOASNOneSpec:MechTypeList OPTIONAL
%%-------------------------------------------------
   {EncBytes1,EncLen1} =  case ?RT_BER:cindex(2,Val,mechTypes) of
         asn1_NOVALUE -> {<<>>,0};
         _ ->
            'enc_MechTypeList'(?RT_BER:cindex(2,Val,mechTypes), [{tag,128,0,'EXPLICIT',32}])
       end,

%%-------------------------------------------------
%% attribute number 2 with type BIT STRING OPTIONAL
%%-------------------------------------------------
   {EncBytes2,EncLen2} =  case ?RT_BER:cindex(3,Val,reqFlags) of
         asn1_NOVALUE -> {<<>>,0};
         _ ->
            ?RT_BER:encode_bit_string([], ?RT_BER:cindex(3,Val,reqFlags), [{delegFlag,0},{mutualFlag,1},{replayFlag,2},{sequenceFlag,3},{anonFlag,4},{confFlag,5},{integFlag,6}], [{tag,128,1,'EXPLICIT',32}])
       end,

%%-------------------------------------------------
%% attribute number 3 with type OCTET STRING OPTIONAL
%%-------------------------------------------------
   {EncBytes3,EncLen3} =  case ?RT_BER:cindex(4,Val,mechToken) of
         asn1_NOVALUE -> {<<>>,0};
         _ ->
            ?RT_BER:encode_octet_string([], ?RT_BER:cindex(4,Val,mechToken), [{tag,128,2,'EXPLICIT',32}])
       end,

%%-------------------------------------------------
%% attribute number 4 with type OCTET STRING OPTIONAL
%%-------------------------------------------------
   {EncBytes4,EncLen4} =  case ?RT_BER:cindex(5,Val,mechListMIC) of
         asn1_NOVALUE -> {<<>>,0};
         _ ->
            ?RT_BER:encode_octet_string([], ?RT_BER:cindex(5,Val,mechListMIC), [{tag,128,3,'EXPLICIT',32}])
       end,

   BytesSoFar = [EncBytes1, EncBytes2, EncBytes3, EncBytes4],
  LenSoFar = EncLen1 + EncLen2 + EncLen3 + EncLen4,
  ?RT_BER:encode_tags(TagIn ++ [{tag,0,16,'IMPLICIT',32}], BytesSoFar, LenSoFar).


'dec_NegTokenInit'(Bytes, OptOrMand) ->
   'dec_NegTokenInit'(Bytes, OptOrMand, []).

'dec_NegTokenInit'(Bytes, OptOrMand, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
   {{_,Len},Bytes1,Rb1} = ?RT_BER:check_tags(TagIn ++ [{tag,0,16,'IMPLICIT',32}], Bytes, OptOrMand), 
{Bytes2,RemBytes} = ?RT_BER:split_list(Bytes1,Len),

%%-------------------------------------------------
%% attribute number 1   External SPNEGOASNOneSpec:MechTypeList OPTIONAL
%%-------------------------------------------------
   {Term1,Bytes3,Rb2} = case Bytes2 of
<<2:2,_:1,0:5,_/binary>> ->
'dec_MechTypeList'(Bytes2, opt_or_default, [{tag,128,0,'EXPLICIT',32}]);
_ ->
{ asn1_NOVALUE, Bytes2, 0 }
end,

%%-------------------------------------------------
%% attribute number 2 with type BIT STRING OPTIONAL
%%-------------------------------------------------
   {Term2,Bytes4,Rb3} = case Bytes3 of
<<2:2,_:1,1:5,_/binary>> ->
?RT_BER:decode_bit_string(Bytes3,[],[{delegFlag,0},{mutualFlag,1},{replayFlag,2},{sequenceFlag,3},{anonFlag,4},{confFlag,5},{integFlag,6}],[{tag,128,1,'EXPLICIT',32}], no_length, mandatory);
_ ->
{ asn1_NOVALUE, Bytes3, 0 }
end,

%%-------------------------------------------------
%% attribute number 3 with type OCTET STRING OPTIONAL
%%-------------------------------------------------
   {Term3,Bytes5,Rb4} = case Bytes4 of
<<2:2,_:1,2:5,_/binary>> ->
?RT_BER:decode_octet_string(Bytes4,[],[{tag,128,2,'EXPLICIT',32}], no_length, mandatory);
_ ->
{ asn1_NOVALUE, Bytes4, 0 }
end,

%%-------------------------------------------------
%% attribute number 4 with type OCTET STRING OPTIONAL
%%-------------------------------------------------
   {Term4,Bytes6,Rb5} = case Bytes5 of
<<2:2,_:1,3:5,_/binary>> ->
?RT_BER:decode_octet_string(Bytes5,[],[{tag,128,3,'EXPLICIT',32}], no_length, mandatory);
_ ->
{ asn1_NOVALUE, Bytes5, 0 }
end,

   {Bytes7,Rb6} = ?RT_BER:restbytes2(RemBytes, Bytes6,noext),
   {{'NegTokenInit', Term1, Term2, Term3, Term4}, Bytes7, Rb1+Rb2+Rb3+Rb4+Rb5+Rb6}.


%%================================
%%  NegTokenResp
%%================================
'enc_NegTokenResp'(Val, TagIn) ->

%%-------------------------------------------------
%% attribute number 1 with type ENUMERATED OPTIONAL
%%-------------------------------------------------
   {EncBytes1,EncLen1} =  case ?RT_BER:cindex(2,Val,negState) of
         asn1_NOVALUE -> {<<>>,0};
         _ ->
            case (case ?RT_BER:cindex(2,Val,negState) of {_,_}->element(2,?RT_BER:cindex(2,Val,negState));_->?RT_BER:cindex(2,Val,negState) end) of
'accept-completed' -> ?RT_BER:encode_enumerated(0,[{tag,128,0,'EXPLICIT',32}]);
'accept-incomplete' -> ?RT_BER:encode_enumerated(1,[{tag,128,0,'EXPLICIT',32}]);
reject -> ?RT_BER:encode_enumerated(2,[{tag,128,0,'EXPLICIT',32}]);
'request-mic' -> ?RT_BER:encode_enumerated(3,[{tag,128,0,'EXPLICIT',32}]);
Enumval1 -> exit({error,{asn1, {enumerated_not_in_range,Enumval1}}})
end
       end,

%%-------------------------------------------------
%% attribute number 2 with type OBJECT IDENTIFIER OPTIONAL
%%-------------------------------------------------
   {EncBytes2,EncLen2} =  case ?RT_BER:cindex(3,Val,supportedMech) of
         asn1_NOVALUE -> {<<>>,0};
         _ ->
            ?RT_BER:encode_object_identifier(?RT_BER:cindex(3,Val,supportedMech), [{tag,128,1,'EXPLICIT',32}])
       end,

%%-------------------------------------------------
%% attribute number 3 with type OCTET STRING OPTIONAL
%%-------------------------------------------------
   {EncBytes3,EncLen3} =  case ?RT_BER:cindex(4,Val,responseToken) of
         asn1_NOVALUE -> {<<>>,0};
         _ ->
            ?RT_BER:encode_octet_string([], ?RT_BER:cindex(4,Val,responseToken), [{tag,128,2,'EXPLICIT',32}])
       end,

%%-------------------------------------------------
%% attribute number 4 with type OCTET STRING OPTIONAL
%%-------------------------------------------------
   {EncBytes4,EncLen4} =  case ?RT_BER:cindex(5,Val,mechListMIC) of
         asn1_NOVALUE -> {<<>>,0};
         _ ->
            ?RT_BER:encode_octet_string([], ?RT_BER:cindex(5,Val,mechListMIC), [{tag,128,3,'EXPLICIT',32}])
       end,

   BytesSoFar = [EncBytes1, EncBytes2, EncBytes3, EncBytes4],
  LenSoFar = EncLen1 + EncLen2 + EncLen3 + EncLen4,
  ?RT_BER:encode_tags(TagIn ++ [{tag,0,16,'IMPLICIT',32}], BytesSoFar, LenSoFar).


'dec_NegTokenResp'(Bytes, OptOrMand) ->
   'dec_NegTokenResp'(Bytes, OptOrMand, []).

'dec_NegTokenResp'(Bytes, OptOrMand, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
   {{_,Len},Bytes1,Rb1} = ?RT_BER:check_tags(TagIn ++ [{tag,0,16,'IMPLICIT',32}], Bytes, OptOrMand), 
{Bytes2,RemBytes} = ?RT_BER:split_list(Bytes1,Len),

%%-------------------------------------------------
%% attribute number 1 with type ENUMERATED OPTIONAL
%%-------------------------------------------------
   {Term1,Bytes3,Rb2} = case Bytes2 of
<<2:2,_:1,0:5,_/binary>> ->
?RT_BER:decode_enumerated(Bytes2,[],[{'accept-completed',0},{'accept-incomplete',1},{reject,2},{'request-mic',3}],[{tag,128,0,'EXPLICIT',32}], mandatory);
_ ->
{ asn1_NOVALUE, Bytes2, 0 }
end,

%%-------------------------------------------------
%% attribute number 2 with type OBJECT IDENTIFIER OPTIONAL
%%-------------------------------------------------
   {Term2,Bytes4,Rb3} = case Bytes3 of
<<2:2,_:1,1:5,_/binary>> ->
?RT_BER:decode_object_identifier(Bytes3,[{tag,128,1,'EXPLICIT',32}], mandatory);
_ ->
{ asn1_NOVALUE, Bytes3, 0 }
end,

%%-------------------------------------------------
%% attribute number 3 with type OCTET STRING OPTIONAL
%%-------------------------------------------------
   {Term3,Bytes5,Rb4} = case Bytes4 of
<<2:2,_:1,2:5,_/binary>> ->
?RT_BER:decode_octet_string(Bytes4,[],[{tag,128,2,'EXPLICIT',32}], no_length, mandatory);
_ ->
{ asn1_NOVALUE, Bytes4, 0 }
end,

%%-------------------------------------------------
%% attribute number 4 with type OCTET STRING OPTIONAL
%%-------------------------------------------------
   {Term4,Bytes6,Rb5} = case Bytes5 of
<<2:2,_:1,3:5,_/binary>> ->
?RT_BER:decode_octet_string(Bytes5,[],[{tag,128,3,'EXPLICIT',32}], no_length, mandatory);
_ ->
{ asn1_NOVALUE, Bytes5, 0 }
end,

   {Bytes7,Rb6} = ?RT_BER:restbytes2(RemBytes, Bytes6,noext),
   {{'NegTokenResp', Term1, Term2, Term3, Term4}, Bytes7, Rb1+Rb2+Rb3+Rb4+Rb5+Rb6}.
